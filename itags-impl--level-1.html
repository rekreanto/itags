
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Itags dev</title>

    <link href= "style--general.css" rel="stylesheet">

    <link href= "style--numbering.css" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.3.1/styles/vs.min.css">
    <script src="lib/highlight.min.js"></script>
    <script src="itags--prelude.js"></script>
 
  </head>
  <body>

<article class="LitProgEssay">


<h1 class="nocount">Itags Level A Implementation</h1>
<p class="intro"><strong>tl;dr</strong> <em>Think of itags level A as fancy dom rendering function or a toy jquery with glanceable syntax.</em></p>
  <p class="intro">Use cases:
    <ol>
      <li>Express HTML Tags and attributes using a uniform readable syntax embedded in js.<li3>
      <li>Render those tags, thus supporting:
        <ul>
          <li>html_tag</li>
          <li>html_tag_attr</li>
          <li>html_tag_class</li>
          <li>html_tag_style</li>
        </ul>
      </li>
      <li>A method for using an array syntax itag to a DOM node <code>[].itag( &lt;elem&gt; )</code></li>
      c
      <li>Some jquery utilties &mdash; just so there is something to play with &mdash; such as:
        <ul>
          <li>Querying with a unique query: <br>
            <code>[ 'queryThe &lt;str query&gt;', &lt;itag+&gt; ]</code></li>
          <li>Querying with an ambigous query: <br>
            <code>[ 'queryAll  &lt;str query&gt;', &lt;itag+&gt; ]</code></li>
          
          <li>Wrapping an existing node:<br>
            <code>[ 'wrap', &lt;node&rarr;itag&gt; ]</code></li>
        </ul>
      </li>
      <li></li>
    </ol>
  </p>
  <p></p>
<h2>Context</h2>
<p>Every itag exists as syntax that can be interpreted as a JavaScript function that takes a context. The context is what gives an itag its power; it is as powerful as what can be done with a context. In Itags level A, the context contains the current node and nothing else.</p>
<script class="listing-here">
  // Context( { node: <node current-node> } )
</script>  
<h3>Normalizing to a Context</h3>

<p>If a node is given where a context is expected, it can be normalized into a context by calling the <code>Context</code> constructor with the node as its single argument. The need for this only appears at the top level and if itags is used for rendering a  non-itags DOM.</p>
<script class="listing-here">
  // Context( <node n> } ) 
  // ~> Context( { node: n } ) 
</script>
<h3>Projecting a Context</h3> 
<p>The Context has <em>value semantics</em> by convention, so modifying a context is forbidden. The way to make a new context based on an old is to "project" it, by e.g. calling the Context constructor with two arguments; the change and the original context. A new context with the required change is returned.</p>  
<script class="listing-here">
  const Context = CaseArity
    ( 1, Normalize( isNode, node => ({ node }) )
    , 2, ( a, b ) => Object.assign( {}, b, a )
    )
  ;
</script>
<h2>js Method for Rendering iTags</h2>
<p>This is a convenience monkey-patched method for executing an itag in syntactic form ( an array, string, number in itags level A ) e.g. on a traditionally defined DOM.</p>
<script class="listing-here">
  Function.prototype.itag = function(){
    return mctx => 
      $$.syntax.itag( this )( Context( mctx )  );
  }
  Number.prototype.itag = function(){
    return mctx => 
      $$.syntax.itag( this )( Context( mctx )  );
  }
  String.prototype.itag = function(){
    return mctx => 
      $$.syntax.itag( this )( Context( mctx )  );
  }
  Array.prototype.itag = function(){
    return mctx => 
      $$.syntax.itag( this )( Context( mctx )  );
  }
</script>

<h2>iTag syntax</h2>
<p></p>
<h3>Name spaces</h3>
<script class="listing-here">
  const $$ = {};  // namespace for utility
  const $$2 = {}; // namespace for metatags of valence 2
  $$.syntax = {};
  $$.syntax.itag = []; // Replace with function at init
  $$.syntax.head = []; // Replace with function at init
</script>
<h3>Functions as itags</h3>
<script class="listing-here">    
  $$.syntax.itag = 
    [ Match, isFunction , fn => fn ]
  ;
</script>
<h3>Arrays interpreted as itags</h3>
<script class="listing-here">
  $$.syntax.itag.push
    ( isArray    
    , ([ head, ...args ]) =>
      $$.syntax.head.call( head )( ...args )
    )
  ;
</script>
<h3>Strings and numbers interpreted as itags</h3>
<script class="listing-here">
  $$.syntax.itag.push
    ( isString   , str => $$2.textnode( str )
    , isNumber   , n   => $$2.textnode( n.toString() )
    )
  ;
</script>

<h2>Metatags for exisisting html constructs</h2>
<h3>Namespace for metatags</h3>
<script class="listing-here">
  $$2.entry = {};
</script>
<h3>The HTML tag metatag</h3>
<script class="listing-here">
  $$2.entry.htmltag = 
    ( tagname )  =>
    ( ...litags ) => // literal itags
    ( ctx     )  => {
      const node = document.createElement( tagname );
      const ctx_ = Context( { node }, ctx );
      for( let litag of litags ) 
        $$.syntax.itag( litag )( ctx_ );
  } 
</script>

<h3>The HTML attr metatag</h3>

<script class="listing-here">

</script>

<h3>The HTML style metatag</h3>
<script class="listing-here">

</script>

<h3>The HTML class metatag</h3>
<script class="listing-here">

</script>




<script>
  document.addEventListener('DOMContentLoaded', (event) => {
    hljs.configure({ ignoreUnescapedHTML: true });
    // find all <script> tags
    document.querySelectorAll('script.listing-here').forEach((el) => {
      const listing = document.createElement( 'pre' );
      const code = document.createElement( 'code' );
      listing.appendChild( code );
      const txt = el.textContent;
      // normalize trailing whitespace
      code.textContent = `${ txt.trimEnd() }\n\n`; 
      code.classList.add('language-js');
      el.parentNode.insertBefore(listing, el);
      hljs.highlightElement( listing );
    });
  });
</script>
  </body>
</html>